<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debugjs | Jerome Etienne.js Blog]]></title>
  <link href="http://blog.jetienne.com/blog/categories/debugjs/atom.xml" rel="self"/>
  <link href="http://blog.jetienne.com/"/>
  <updated>2013-04-24T06:00:26+02:00</updated>
  <id>http://blog.jetienne.com/</id>
  <author>
    <name><![CDATA[Jerome Etienne]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Debug.js: Automatic Globals Detection in Javascript]]></title>
    <link href="http://blog.jetienne.com/blog/2013/04/23/debug-dot-js-global-detection/"/>
    <updated>2013-04-23T07:43:00+02:00</updated>
    <id>http://blog.jetienne.com/blog/2013/04/23/debug-dot-js-global-detection</id>
    <content type="html"><![CDATA[<p>This post is about detecting global variables in javascript and eradicating them :)
This is a first post about <a href="https://github.com/jeromeetienne/debug.js">debug.js</a>,
a library to make javascript easier to debug.
Global Detection is one of the features of this library.
I came up with the idea back in May 2012 at
<a href="https://twitter.com/web_rebels">Web Rebels</a> at Oslo.
So i was quite enthusiatic and started coding right away on the plane back home.
Now, <a href="https://github.com/jeromeetienne/debug.js">debug.js</a> has quite a bit of features.
In future posts, we will detail them and explain how they can be useful in your own code.</p>

<iframe width="420" height="315" src="http://www.youtube.com/embed/dZzs4q3NFu8" frameborder="0" allowfullscreen></iframe>




<!-- more -->


<h2>Debug.js Overview</h2>

<p><a href="https://github.com/jeromeetienne/debug.js">debug.js</a> addresses various known issues which make javascript hard to debug.
For example, <a href="https://github.com/jeromeetienne/debug.js">debug.js</a> implements strong type checking,
for object properties and for function parameters. So you can check that a function is
called the way you expect, with the precise number of parameters, for each parameter you
can specify the allowed types: number, string.. for instance of your own classes
like <code>THREE.Vector3</code>.</p>

<p>It implements value bound checking, to ensure a value of variable remains in the range
you expect (<a href="http://en.wikipedia.org/wiki/Bounds_checking">read more</a>).
It implements NaN checking to be sure your math computation
doesn't end up with <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/NaN">NaN</a>.
With plain js, it is silently ignored, with <a href="https://github.com/jeromeetienne/debug.js">debug.js</a>, you are warned immediatly.
Many other feature are like that.</p>

<p>Oh and an <em>important feature</em>,
<a href="https://github.com/jeromeetienne/debug.js">debug.js</a>
is javascript.
It works in browser and node.js.
It isnt another language which is compiled to javascript.
You can keep your current code, your current developpers and their current knowledge.
Now that you got a better idea of what is <a href="https://github.com/jeromeetienne/debug.js">debug.js</a>.
Let's go deeper on a specific part: the global detection</p>

<h1>Globals Detection</h1>

<p>Ok, so let's detect some globals.
You first need to get the files which contain the code.
As for the rest of debug.js, the global detection works in browsers and in node.js.
If you are in node.js, you do the usual <code>require()</code>
(see <a href="http://nodejs.org/api/globals.html#globals_require">more</a>).</p>

<p><code>javascript
var GlobalDetector = require('globaldetector.js');
</code></p>

<p>If you are in a browser, just add a <code>&lt;script&gt;</code></p>

<p>```html</p>

<script src='debug-bundle.js'></script>


<p>```</p>

<p>Now that we got the code, let's get started!</p>

<h2>Start Detecting Globals</h2>

<p>The principle behind global detection is simple.
The global object is monitored, so <code>window</code> in a browser and <code>global</code> in node.js.
The monitoring is tuned to detect any new property attached to it.
So any new global defined will be attached to the global object and detected on the next run
of the global detector.
To start the global detector, just add the following lines.</p>

<p><code>javascript
// instanciate the object
var globalDetector = new GlobalDetector();
// start monitoring globals
globalDetector.start();
</code></p>

<p>By default, it monitors the globals once per second
and reports any new ones via <code>console.warn()</code>.
If you wish another behavior, see the <a href="http://jeromeetienne.github.com/debug.js/docs/jsdocs/">API documentation</a>
and tune the parameters.
If the variable <code>foo</code> is detected, you will see something like this.</p>

<p><code>
Thu Dec 06 2012 19:10:15 GMT+0100 (CET) -- Warning Global Detected!!! window['foo'] === bar
</code></p>

<h2>How To Allow Globals</h2>

<p>Nevertheless, sometimes it is ok to have globals.
For example, if you use <a href="http://example.com">jQuery</a>, a <code>jQuery</code> global will be defined.
No need for GlobalDetector to report this one.
Just use the following line to warn the library to ignore this particular property.</p>

<p><code>javascript
GlobalDetector.ignoreList.push('jQuery');
</code></p>

<h1>Globals Removal</h1>

<p>To detect the presence and name of global variables is nice, but it doesn't fix the issue.
The globals are still here.
debug.js goes further and helps you track where those globals are used.
Thus you can change your code to avoid globals and be sure you don't miss any spot.</p>

<p>Tracking the usage of globals is a 2 step process: you have to launch the application twice.
First you detect the globals as described above and you generate the code needed
for the usage tracker, then second, you relaunch to collect where those globals are used.</p>

<h2>Step 1: Generating the Code Needed for Usage Tracker</h2>

<p>So on the first run, you include and start the global detector as described above.
You let it run for a while, and then you generate the code for the usage tracker.
Just use the following line.
It will dump the code you need to include in the second pass.
It is as simple as that.</p>

<p><code>javascript
globalDetector.usageTrackerCodeConsole();
</code></p>

<p>This one will output the code in the javascript console.
If you want to output the code in another window, just use <code>.usageTrackerCodeWindow()</code>.
Include this tracking code in your application, and you are all
set for the second pass.</p>

<p><code>javascript
PropertyAttr.define(window, 'foo').trackUsage('window.foo');
</code></p>

<h2>Step 2: Actually Tracking Usage of Globals</h2>

<p>So on the second run, you included the tracking code.
So you let your application run, and the usage location of each global will be recorded.
To know where your globals are used, just use this line in your javascript console.</p>

<p><code>javascript
globalDetector.usageTrackerDump();
</code></p>

<p>It will dump where it is used and how many times.
You will see something quite similar to the following.
It is possible to fine tune the report, see <code>Stacktrace.Tracker</code> in the
<a href="http://jeromeetienne.github.com/debug.js/docs/jsdocs/">API documentation</a>.</p>

<p>```
window.foo: total 2 times</p>

<pre><code>aClass.aMethod@http://example.com/index.html:30 - 1 times
aClass.anotherMethod@http://example.com/index.html:32 - 1 times 
</code></pre>

<p>```</p>

<p>So you got where the globals are used and can start fixing your code to remove
the globals.</p>

<h2>Why globals are bad</h2>

<p>Wait... why is this needed ?
A legitimate question to ask.
So Why globals are bad ?
Because <strong>Globals are considered harmful</strong> by most people and it is so in any language.
Globals are bad in javascript, globals are bad in C++, globals are bad in perl etc...
You got the picture.
Why is that ? Because globals got:</p>

<p><strong>Non-locality</strong> Source code is easiest to understand when the scope of its individual elements are limited. Global variables can be read or modified by any part of the program, making it difficult to remember or reason about every possible use.</p>

<p><strong>No Access Control</strong> A global variable can be get or set by any part of the program, and any rules regarding its use can be easily broken or forgotten. (In other words, get/set accessors are generally preferable over direct data access, and this is even more so for global data.)</p>

<p><strong>Implicit coupling</strong> A program with many global variables often has tight couplings between some of those variables, and couplings between variables and functions. Grouping coupled items into cohesive units usually leads to better programs.</p>

<p><strong>Namespace pollution</strong> Global names are available everywhere. You may unknowingly end up using a global when you think you are using a local (by misspelling or forgetting to declare the local) or vice versa.</p>

<p>Those rules are quoted directly from a very good paper on this exact subject
"<a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">why globals are bad</a>".</p>

<h2>Conclusion</h2>

<p>This post is the first on
<a href="https://github.com/jeromeetienne/debug.js">debug.js</a>.
It explains a specific part of it
: the global detection.
We first explained how to detect the presence of globals, and their names.
Then we detailed how to track their usage to better remove them.
So with <a href="https://github.com/jeromeetienne/debug.js">debug.js</a>
, you can find out the globals used in your application and then remove it.</p>

<p>We think this feature is quite important when you have a large
codebase and need to maintain it over a long time, like
it is usual in software companies.
In this case, it is best to monitor such a thing and keep it under control.
Companies got to have processes for that... things people call
<a href="http://en.wikipedia.org/wiki/Quality_assurance">Quality Assurance or Q/A</a>.
debug.js and its global detection has been designed to fit nicely in a Q/A process.</p>

<p>In our next posts about debug.js, we will see other important parts of the library,
such as
how to reduce garbage collection via monitoring+object pooling,
how to have private/public members in your javascript classes,
or
strong type checking.
Additionaly, debug.js works real well when coupled with jsdoc information.
Stay tuned.</p>

<p>That's all folks, have fun :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug.js: assertWhichStop.js]]></title>
    <link href="http://blog.jetienne.com/blog/2013/04/18/debug-dot-js-assertwhichstop-dot-js/"/>
    <updated>2013-04-18T15:15:00+02:00</updated>
    <id>http://blog.jetienne.com/blog/2013/04/18/debug-dot-js-assertwhichstop-dot-js</id>
    <content type="html"><![CDATA[<p>This is post presents <em>assertWhichStop.js</em>.
<a href="https://github.com/jeromeetienne/debug.js/tree/master/src">assertWhichStop.js</a>
is a simple library which provide an <code>assert()</code> which stops...
who would have guessed :)
You may find that surprising but in your browser,
javascript's
<a href="https://getfirebug.com/wiki/index.php/Console_API#console.assert.28expression.5B.2C_object.2C_....5D.29">assert()</a>
does not stop the execution of the code but it does in other languages.
<a href="https://github.com/jeromeetienne/debug.js/tree/master/src">assertWhichStop.js</a>
will make your assert stop even in your browser.</p>

<p><a href="https://github.com/jeromeetienne/debug.js/tree/master/src">assertWhichStop.js</a>
is a part of
<a href="https://github.com/jeromeetienne/debug.js">debug.js</a> library,
which we talked about in <a href="/blog/categories/debugjs/">previous posts</a>.
This post will explain why it is usefull to stop and how to use <em>assertWhichStop.js</em>.
This library is
<a href="https://github.com/jeromeetienne/debug.js/blob/master/src/assertwhichstop.js">very small</a>
, barely 10 lines full total at the time of writing.
It is based on a little
<a href="https://gist.github.com/2651899">gist</a>
we did in collaboration with
<a href="https://plus.google.com/118110542957297456336/posts">jens arp</a>.
Ok now let's see more deeply what is assert.</p>

<!-- more -->


<h3>What Is Assert() ?</h3>

<p><a href="http://en.wikipedia.org/wiki/Assertion_(computing)">Assert</a>
is a very usefull tool during developement.
It is done to <strong>explicitly check internal consistency</strong>.
In other words, it is a way to say <em>"ok here, this MUST be true. And if it isn't, there is a bug"</em>.
You explicitly describe the assertions you make in your code
and
get immediatly notified when one happened to be wrong.
So you can fix the bug.</p>

<p><a href="http://en.wikipedia.org/wiki/Assertion_(computing)">Assert</a>
is from
<a href="http://en.wikipedia.org/wiki/C_(programming_language)">c</a>
/
<a href="http://en.wikipedia.org/wiki/C%2B%2B">c++</a>.
It is available in many languages: in
<a href="http://docs.python.org/3.3/reference/simple_stmts.html#the-assert-statement">python</a>,
<a href="http://php.net/manual/en/function.assert.php">php</a>,
or even done in
<a href="http://search.cpan.org/~mschwern/Carp-Assert-0.20/lib/Carp/Assert.pm">perl</a>.
In most language, the execution is stopped immediatly: thru exception for
<a href="http://docs.python.org/3.3/reference/simple_stmts.html#the-assert-statement">python</a>
or
<a href="http://php.net/manual/en/function.assert.php">php</a>
, or thru
<a href="http://en.wikipedia.org/wiki/Unix_signal">unix signal</a>
+
<a href="http://en.wikipedia.org/wiki/Core_dump">coredump</a>
with
<a href="http://en.wikipedia.org/wiki/C_(programming_language)">c</a>
/
<a href="http://en.wikipedia.org/wiki/C%2B%2B">c++</a>.
Thus you get notified of the bugs early,
study the situation and start fixing.</p>

<h3>Let's Get Started</h3>

<p>You first need to get the files which contains the code.
As for the rest of debug.js, the global detection works in browsers and in node.js.
If you are in node.js, you do the usual <code>require()</code>
(see <a href="http://nodejs.org/api/globals.html#globals_require">more</a>).</p>

<p><code>javascript
var GlobalDetector = require('assertwhichstop.js');
</code></p>

<p>If you are in a browser, just add a <code>&lt;script&gt;</code></p>

<p>```html</p>

<script src='debug-bundle.js'></script>


<p>```</p>

<h3>How To Use It ?</h3>

<p>Now that we got the code included, let's see how to use it.
The typical usage will be like that</p>

<p><code>javascript
assertWhichStop(condition, message);
</code></p>

<p>If the asserted condition is true, nothing will happen.
If it is false, the message will be displayed and it will try to stop the execution of the programm.
Suppose you got a variable <code>foo</code> which is supposed to always be a number greater than 0.
You will typically do something like that.</p>

<p><code>javascript
assertWhichStop( foo &gt; 0, "foo MUST be greater than 0");
</code></p>

<p>This will stop the execution if <code>foo</code> isn't greater than 0. Simple enougth :)
Sure but how does it try to stop ? Let's look at that.</p>

<h3>How To Stop ?</h3>

<p>assertWhichStop can stop in 2 ways:
The first one is by throwing an exception with <a href="http://example.com/mdn">Error</a>
It is the most natural way.
So it is the default behavior.</p>

<p>Additionnaly it is possible to stop by triggering the js debugger itself.
This generate a total halt. Nothing will happen anymore in the page.
It uses <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/debugger"><code>debugger;</code> javascript statement</a>
It isn't a well known part of javascript but it is
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-12.15">standard javascript</a>.
Unfortunatly it seems to be implemented only on chrome at the moment.
When the virtual machine hits it, it will popup the
<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/debugger">javascript debugger</a>,
so you can get the call stack, get the local variables,
set up conditions to watch or many other things. Usefull stuff to debug.</p>

<h3>Overloading Console API for Backward Compatibility</h3>

<p>If you wish, you can overload the <code>console.assert</code> with the following line.
Thanks to that, you can easily take advantage of
assertWhichStop.js without changing your code, a nice feature :)</p>

<p><code>javascript
assertWhichStop.overloadConsole();
</code></p>

<p>After this, any <code>console.assert()</code> will use assertWhichStop and will be able to stop as
soon as an assertion is found wrong.</p>

<h2>Conclusion</h2>

<p>If this post, we talked about
why assert is usefull during  developement to keep your code running as you expect.
We have seen
how to use <a href="https://github.com/jeromeetienne/debug.js/tree/master/src">assertWhichStop.js</a>
to immediatly stop when one of your assertion happened to be wrong.
Thus then you can fix the bug as soon as possible.
We got various ways to stop: exception or <code>debugger;</code> statement, a part of standard javascript.
All that in a backward compatible fashion... rather cool if you ask me :)</p>

<p>That's all folks, have fun!</p>
]]></content>
  </entry>
  
</feed>
